package iris

import (
	"github.com/agilira// Simplified spinning strategy for low latency
type Ring struct {
	// Embedded Zephyros Light engine
	z *zephyroslite.ZephyrosLight[Record]errors"
	"github.com/agilira/iris/internal/zephyroslite"
)

// ProcessorFunc defines the signature for record processing functions
//
// This function is called for each log record that flows through the ring buffer.
// It should be efficient and avoid blocking operations to maintain high throughput.
//
// Parameters:
//   - record: The log record to process (guaranteed non-nil)
//
// Performance Notes:
//   - Called from the consumer thread only (single-threaded)
//   - Should avoid allocations and blocking operations
//   - Can safely access shared state (no concurrent access)
type ProcessorFunc func(record *Record)

// Ring provides ultra-high performance logging with embedded Zephyros Light
//
// The Ring uses the embedded ZephyrosLight engine to provide optimal performance
// for logging operations while eliminating external dependencies and maintaining
// the core features needed for high-performance logging.
//
// Embedded Zephyros Light Features:
//   - Single ring architecture optimized for logging
//   - ~15-20ns/op performance (vs 9ns commercial, 25ns previous)
//   - Zero heap allocations during normal operation
//   - Lock-free atomic operations for maximum throughput
//   - Fixed batch processing (simplified vs adaptive)
//
// Architecture Simplification:
//   - SingleRing only (ThreadedRings removed - commercial feature)
//   - Simplified configuration (fewer options, better defaults)
//   - Embedded implementation (no external dependencies)
//
// Performance Characteristics:
//   - Zero heap allocations during normal operation
//   - Lock-free atomic operations for maximum throughput
//   - Fixed batching optimized for logging workloads
//   - Simplified spinning strategy for low latency
type Ring struct {
	// Embedded Zephyros Light engine
	z *zephyroslight.ZephyrosLight[Record]

	// Configuration
	capacity  int64 // Ring buffer capacity (power of two)
	batchSize int64 // Processing batch size
}

// newRing creates a new ultra-high performance logging ring buffer with embedded Zephyros Light
//
// This simplified version uses the embedded ZephyrosLight engine optimized for logging,
// removing the complexity of architecture selection while maintaining excellent performance.
//
// Parameters:
//   - capacity: Ring buffer size (must be power of two, e.g., 1024, 2048, 4096)
//   - batchSize: Processing batch size (0 for auto-sizing based on capacity)
//   - architecture: Ignored (kept for API compatibility, always uses embedded engine)
//   - numRings: Ignored (kept for API compatibility, single ring architecture)
//   - processor: Function to process each log record
//
// Embedded Zephyros Light Features:
//   - ~15-20ns/op performance (significant improvement over previous 25ns)
//   - Zero allocations for write operations
//   - Lock-free MPSC operations
//   - Fixed batch processing optimized for logging
//   - No external dependencies
//
// Performance Recommendations:
//   - Use capacity 1024-8192 for most applications
//   - Use batchSize 64-256 for balanced latency/throughput
//   - Use capacity as power of two for optimal bit masking
//
// Returns:
//   - *Ring: Configured ring buffer with embedded Zephyros Light engine
//   - error: Configuration error if parameters are invalid
func newRing(capacity, batchSize int64, architecture Architecture, numRings int, processor ProcessorFunc) (*Ring, error) {
	// Params architecture and numRings are kept for API compatibility but not used
	// as this simplified version always uses the embedded Zephyros Light engine
	_ = architecture // Explicitly mark as unused (kept for API compatibility)
	_ = numRings     // Explicitly mark as unused (kept for API compatibility)

	// Validate capacity (must be power of two)
	if capacity <= 0 || (capacity&(capacity-1)) != 0 {
		return nil, NewLoggerError(ErrCodeRingInvalidCapacity, "ring capacity must be a power of two and greater than zero").
			WithContext("capacity", capacity).
			WithContext("valid_examples", "[64, 128, 256, 512, 1024, 2048, 4096, 8192]")
	}

	// Validate processor function
	if processor == nil {
		return nil, NewLoggerError(ErrCodeRingMissingProcessor, "ring processor function is required")
	}

	// Auto-size batch if not specified
	if batchSize == 0 {
		if capacity >= 1024 {
			batchSize = 256 // Optimized for logging workloads (compatible with tests)
		} else if capacity >= 64 {
			batchSize = capacity / 4 // Quarter of capacity for small buffers
		} else {
			batchSize = 1 // Minimal for very small buffers
		}
	}

	// Validate batch size
	if batchSize <= 0 || batchSize > capacity {
		return nil, NewLoggerError(ErrCodeRingInvalidBatchSize, "ring batch size must be positive and not exceed capacity").
			WithContext("batch_size", batchSize).
			WithContext("capacity", capacity).
			WithContext("max_batch", capacity)
	}

	ring := &Ring{
		capacity:  capacity,
		batchSize: batchSize,
	}

	// Create embedded Zephyros Light processor wrapper
	zephyrosProcessor := func(record *Record) {
		processor(record)
	}

	// Create embedded Zephyros Light ring buffer
	builder := zephyroslight.NewBuilder[Record](capacity).
		WithProcessor(zephyrosProcessor).
		WithBatchSize(batchSize)

	var err error
	ring.z, err = builder.Build()
	if err != nil {
		return nil, errors.Wrap(err, ErrCodeRingBuildFailed, "failed to build embedded Zephyros Light ring buffer").
			WithContext("capacity", capacity).
			WithContext("batch_size", batchSize).
			WithContext("engine", "zephyros_light")
	}

	return ring, nil
}

// Write adds a log record to the ring buffer using zero-allocation pattern
//
// The fill function is called with a pointer to a pre-allocated Record in the
// embedded Zephyros Light ring buffer. This avoids any heap allocations during
// logging operations while providing excellent performance.
//
// The function is thread-safe and can be called concurrently from multiple
// goroutines. The embedded ZephyrosLight uses atomic operations for
// lock-free performance.
//
// Performance: Target ~15-20ns/op with embedded Zephyros Light engine
//
// Parameters:
//   - fill: Function to populate the log record (called with pre-allocated Record)
//
// Returns:
//   - bool: true if record was successfully written, false if ring is full or closed
//
// Performance Notes:
//   - Zero heap allocations during normal operation
//   - Lock-free atomic operations for maximum throughput
//   - Returns false instead of blocking when ring is full
//   - Optimized for high-frequency logging scenarios
//
// Example:
//
//	success := ring.Write(func(r *Record) {
//	    r.Level = ErrorLevel
//	    r.Message = "Critical error occurred"
//	    r.Timestamp = time.Now()
//	})
func (r *Ring) Write(fill func(*Record)) bool {
	// Simplified: Direct write to embedded ZephyrosLight
	return r.z.Write(fill)
}

// Flush ensures all pending writes are visible to the consumer
//
// In the embedded ZephyrosLight architecture, this method ensures that all writes
// from producer threads are visible to the consumer thread. This is primarily
// useful for testing and ensuring deterministic behavior.
//
// Note: In normal operation, flushing is automatic and this method exists
// primarily for API compatibility and testing scenarios.
func (r *Ring) Flush() {
	// Simplified: Direct flush to embedded ZephyrosLight
	r.z.Flush()
}

// Loop starts the record processing loop (CONSUMER THREAD ONLY)
//
// This method should be called from exactly one goroutine to consume and
// process log records. The embedded ZephyrosLight implements an optimized
// spinning strategy for balanced performance and CPU usage.
//
// The loop continues until Close() is called, after which it processes
// all remaining records before exiting.
//
// Performance Features:
//   - Fixed batching optimized for logging workloads
//   - Simplified idle strategy to minimize CPU usage
//   - Guaranteed processing of all records during shutdown
//
// Warning: Only call this method from one goroutine per ring buffer.
// Multiple consumers will cause race conditions and data loss.
func (r *Ring) Loop() {
	// Simplified: Direct loop processing with embedded ZephyrosLight
	r.z.LoopProcess()
}

// ProcessBatch processes a single batch of records and returns the count
//
// This method is useful for custom consumer implementations that need
// fine-grained control over processing timing. It processes up to batchSize
// records in a single call using the embedded ZephyrosLight engine.
//
// Returns:
//   - int: Number of records processed in this batch (0 if no records available)
//
// Note: This is a lower-level method. Most applications should use Loop()
// which handles the complete consumer lifecycle automatically.
func (r *Ring) ProcessBatch() int {
	// Simplified: Direct batch processing with embedded ZephyrosLight
	return r.z.ProcessBatch()
}

// Close gracefully shuts down the ring buffer
//
// This method signals the consumer to stop processing and ensures all
// buffered records are processed before shutdown. It is safe to call
// multiple times and from multiple goroutines.
//
// After Close() is called:
//   - Write() will return false for all subsequent calls
//   - Loop() will process all remaining records and then exit
//   - The ring buffer becomes unusable
//
// Shutdown Guarantees:
//   - All buffered records are processed before shutdown
//   - Multiple Close() calls are safe (idempotent)
//   - Deterministic shutdown behavior for testing
func (r *Ring) Close() {
	// Simplified: Direct close with embedded ZephyrosLight
	r.z.Close()
}

// Stats returns detailed performance statistics for monitoring and debugging
//
// The returned map contains real-time metrics about the embedded ZephyrosLight
// ring buffer's performance and current state. This is useful for monitoring,
// alerting, and performance optimization.
//
// Returned Statistics:
//   - "writer_position": Last claimed sequence number
//   - "reader_position": Current reader position
//   - "buffer_size": Total ring buffer capacity
//   - "items_buffered": Number of records waiting to be processed
//   - "items_processed": Total records processed
//   - "items_dropped": Total records dropped due to full buffer
//   - "closed": Ring buffer closed state (0=open, 1=closed)
//   - "capacity": Configured ring capacity
//   - "batch_size": Configured batch size
//   - "utilization_percent": Buffer utilization percentage
//   - "engine": "zephyros_light" (embedded engine identifier)
//
// Returns:
//   - map[string]int64: Real-time performance statistics
//
// Example:
//
//	stats := ring.Stats()
//	fmt.Printf("Buffer utilization: %d%%\n", stats["utilization_percent"])
//	fmt.Printf("Items buffered: %d\n", stats["items_buffered"])
func (r *Ring) Stats() map[string]int64 {
	// Get stats from embedded ZephyrosLight
	stats := r.z.Stats()

	// Create result map with Ring-specific additions
	result := make(map[string]int64)

	// Copy all ZephyrosLight stats
	for k, v := range stats {
		result[k] = v
	}

	// Add Ring-specific stats
	result["capacity"] = r.capacity
	result["batch_size"] = r.batchSize
	result["engine"] = 1      // 1 = zephyros_light embedded
	result["go_routines"] = 1 // Single processing goroutine (compatibility)

	// Calculate utilization percentage
	if itemsBuffered, exists := stats["items_buffered"]; exists && r.capacity > 0 {
		result["utilization_percent"] = (itemsBuffered * 100) / r.capacity
	}

	return result
}
